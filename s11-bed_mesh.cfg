#####################################################################
#  Bed Mesh Definition
#####################################################################
[bed_mesh]
##  Start end end point of mesh 
mesh_min: 30,30
mesh_max: 320,320
speed: 1000
##   The height (in mm) that the head should be commanded to move to
##   just prior to starting a probe operation. The default is 5.
horizontal_move_z: 1 ; Nozzle
probe_count: 7#9,9
##   The interpolation algorithm to use. May be either "lagrange"
##   or "bicubic". This option will not affect 3x3 grids, which
##   are forced to use lagrange sampling.  Default is lagrange.
algorithm: bicubic
## [(9x9)-1] / 2 = 40
## [(7x7)-1] / 2 = 24
## [(5x5)-1] / 2 = 12
##   When the probed points are generated they are each assigned an index. 
##   You can look up this index in klippy.log or by using BED_MESH_OUTPUT (see the section on Bed Mesh GCodes below for more information). 
##   If you assign an index to the relative_reference_index option, the value probed at this coordinate will replace the probe's z_offset. 
##   This effectively makes this coordinate the "zero" reference for the mesh.
relative_reference_index: 24 #40
##   The gcode z position in which to start phasing out z-adjustment
##   when fade is enabled.  Default is 1.0.
#fade_start: 1
##   The gcode z position in which phasing out completes.  When set
##   to a value below fade_start, fade is disabled. It should be
##   noted that fade may add unwanted scaling along the z-axis of a
##   print.  If a user wishes to enable fade, a value of 10.0 is
##   recommended. Default is 0.0, which disables fade.
#fade_end: 10
##   The z position in which fade should converge. When this value is set
##   to a non-zero value it must be within the range of z-values in the mesh.
##   Users that wish to converge to the z homing position should set this to 0.
##   Default is the average z value of the mesh.
#fade_target: 0
##   The distance (in mm) along a move to check for split_delta_z.
##   This is also the minimum length that a move can be split. Default
##   is 5.0.
#move_check_distance: 3
##   The amount of Z difference (in mm) along a move that will
##   trigger a split. Default is .025.
#split_delta_z: 0.0125
##   A comma separated pair of integers (X,Y) defining the number of
##   points per segment to interpolate in the mesh along each axis. A
##   "segment" can be defined as the space between each probed
##   point. The user may enter a single value which will be applied
##   to both axes.  Default is 2,2.
#mesh_pps: 2,2
##   When using the bicubic algorithm the tension parameter above
##   may be applied to change the amount of slope interpolated.
##   Larger numbers will increase the amount of slope, which
##   results in more curvature in the mesh. Default is .2.
#bicubic_tension: 0.2

#####################################################################
#  Macros
#####################################################################
#
# Warning: If you use the flexplate names insight your stored mesh's than:
#  - insure that it does not contain spaces
#  - insure that it does not contain special charakters
#  - insure that it does not contain german "umlaut" (äöü and ß)
#
# All macros are writen in the way that they will work without a [save_variables]
# block and also without the flexplate.cfg
#
#####################################################################
[gcode_macro BED_MESH_CALIBRATE_Alex]
description: Perform QGL and bed mesh leveling
#rename_existing: BED_MESH_CALIBRATE_BASE
gcode:
  {% set user = printer['gcode_macro _USER_VARIABLE'] %}
  {% if "xyz" not in printer.toolhead.homed_axes %} G28 {% endif %}
  BED_MESH_CLEAR
  {% if not printer.quad_gantry_level.applied %} QUAD_GANTRY_LEVEL PARK=false {% endif %}
  {% if user.hw.mag_probe.ena %} ATTACH_PROBE {% endif %}
  BED_MESH_CALIBRATE_BASE {rawparams}
  {% if user.hw.mag_probe.ena %} DETACH_PROBE {% endif %}


[gcode_macro BED_MESH_CALIBRATE]
rename_existing: BED_MESH_CALIBRATE_BASE
; gcode parameters
variable_parameter_AREA_START : 0,0
variable_parameter_AREA_END : 0,0
; the clearance between print area and probe area 
variable_mesh_area_offset : 5.0
; number of sample per probe point
variable_probe_samples : 2
; minimum probe count
variable_min_probe_count : 3
; scale up the probe count, should be 1.0 ~ < variable_max_probe_count/variable_min_probe_count
variable_probe_count_scale_factor : 1.0
; enable preference index
variable_enable_reference_index : False

variable_mesh_delta : 30                   ## distance between points
variable_x_mesh_max : 9                    ## max points on x-axis
variable_y_mesh_max : 9                    ## max points on y-axis

gcode:
  {% set user = printer['gcode_macro _USER_VARIABLE'] %}
  {% if "xyz" not in printer.toolhead.homed_axes %} G28 {% endif %}
  BED_MESH_CLEAR
  {% if not printer.quad_gantry_level.applied %} QUAD_GANTRY_LEVEL PARK=false {% endif %}
   

	{% if params.AREA_START and params.AREA_END %}
	## get [bed_mesh] config parameters
		{% set bedMeshConfig = printer["configfile"].config["bed_mesh"] %}
		{% set safe_min_x = bedMeshConfig.mesh_min.split(",")[0]|float %}
		{% set safe_min_y = bedMeshConfig.mesh_min.split(",")[1]|float %}
		{% set safe_max_x = bedMeshConfig.mesh_max.split(",")[0]|float %}
		{% set safe_max_y = bedMeshConfig.mesh_max.split(",")[1]|float %}
	## get print area min/max from slicer gcode
		{% set area_min_x = params.AREA_START.split(",")[0]|float %}
		{% set area_min_y = params.AREA_START.split(",")[1]|float %}
		{% set area_max_x = params.AREA_END.split(",")[0]|float %}
		{% set area_max_y = params.AREA_END.split(",")[1]|float %}
	## set probing area
		{% if area_min_x - mesh_area_offset >=  safe_min_x %}
			{% set area_min_x = area_min_x - mesh_area_offset %}
			{% else %}
			{% set area_min_x = safe_min_x %}
		{% endif %}
		{% if area_min_y - mesh_area_offset >=  safe_min_y %}
			{% set area_min_y = area_min_y - mesh_area_offset %}
			{% else %}
			{% set area_min_y = safe_min_y %}
		{% endif %}
		{% if area_max_x + mesh_area_offset <=  safe_max_x %}
			{% set area_max_x = area_max_x + mesh_area_offset %}
			{% else %}
			{% set area_max_x = safe_max_x %}
		{% endif %}
		{% if area_max_y + mesh_area_offset <=  safe_max_y %}
			{% set area_max_y = area_max_y + mesh_area_offset %}
			{% else %}
			{% set area_max_y = safe_max_y %}
		{% endif %}
	## set probe counts
		{% set meshPointX = ((area_max_x - area_min_x) / mesh_delta + 1)|round(0)|int %}
		{% if meshPointX < 3 %}
			{% set meshPointX = 3 %}
			{% elif meshPointX > x_mesh_max %}
			{% set meshPointX = x_mesh_max %}
		{% endif %}
		{% set meshPointY = ((area_max_y - area_min_y) / mesh_delta + 1)|round(0)|int %}
		{% if meshPointY < 3 %}
			{% set meshPointY = 3 %}
			{% elif meshPointY > y_mesh_max %}
			{% set meshPointY = y_mesh_max %}
		{% endif %}
	## check for invalid mesh
		{% if meshPointX > 5 %}
			{% if meshPointY == 3 %}  # 7x3 mesh invalid for bicubic
			{% set meshPointY = 5 %}  # set 7x5 mesh
			{% endif %}
		{% endif %}
		{% if meshPointY > 5 %}
			{% if meshPointX == 3 %}  # 3x7 mesh invalid for bicubic
			{% set meshPointX = 5 %}  # set 5x7 mesh
			{% endif %}
		{% endif %}
	## set new reference index point
		{% set referenceIndex = (meshPointX * meshPointY / 2 - 1 )|round(0)|int %}
	## send bed mesh parameters
		M117 probe_count={meshPointX},{meshPointY}
		BED_MESH_CALIBRATE_BASE mesh_min={area_min_x},{area_min_y} mesh_max={area_max_x},{area_max_y} probe_count={meshPointX},{meshPointY} relative_reference_index={referenceIndex} 
	{% else %}
	BED_MESH_CALIBRATE_BASE
	{% endif %}


## use BED_MESH_STORE                       -> generate MESH and park in the middle
## use BED_MESH_STORE SAVE=now              -> generate MESH and park in the middle and save immediately 
## use BED_MESH_STORE PARK=false            -> generate MESH
## use BED_MESH_STORE SAVE=later            -> generate MESH and park in the middle and save it later 
[gcode_macro BED_MESH_STORE]
description: Generate a mesh, name it and run save_config if requested
variable_save_at_end: False
gcode:
  {% set user = printer['gcode_macro _USER_VARIABLE'] %}
  {% set name = '' if printer.save_variables.variables.plates is not defined 
           else printer.save_variables.variables.plates.array[printer.save_variables.variables.plates.index].name + '-' %}
  {% set mesh_name = name + "Bed_Temp-" + printer.heater_bed.target|int|string + "C" %}
  {action_respond_info("BED_MESH: Generate \"%s\"" % mesh_name)}
  BED_MESH_CALIBRATE PROFILE={mesh_name}
  {% if params.PARK|default('true')|lower == 'true' %}
    G90                                                                  ; set absolute
    G0 Z{user.park.bed.z} F{user.speed.z_hop}                            ; lift first
    G0 X{user.park.bed.x} Y{user.park.bed.y} F{user.speed.travel}         ; park toolhead
    {% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %} ; set it back to relative
  {% endif %}
  {% if params.SAVE|default('none')|lower == 'now' %}
    _PRINT_AR T="BED_MESH: Save Config!"
    SAVE_CONFIG
  {% elif params.SAVE|default('none')|lower == 'later' %}
    _PRINT_AR T="BED_MESH: Save Config after print done"
    SET_GCODE_VARIABLE MACRO=BED_MESH_STORE VARIABLE=save_at_end VALUE=True
  {% endif %}

## use BED_MESH_LOAD           -> load an existing MESH
## use BED_MESH_LOAD AUTO=true -> load an existing MESH or generate a new one and prepare it to be saved after print end
[gcode_macro BED_MESH_LOAD]
description: Load an existing mesh or generate a new one
gcode:
  {% set name = '' if printer.save_variables.variables.plates is not defined 
           else printer.save_variables.variables.plates.array[printer.save_variables.variables.plates.index].name + '-' %}
  {% set mesh_name = name + "Bed_Temp-" + printer.heater_bed.target|int|string + "C" %}
  {% if printer.configfile.config["bed_mesh " + mesh_name] is defined %}
    {action_respond_info("BED_MESH: \"%s\" loaded" % mesh_name)}
    BED_MESH_CLEAR
    BED_MESH_PROFILE LOAD={mesh_name}
  {% elif params.AUTO|default('false')|lower == 'true' %}
    {action_respond_info("BED_MESH: \"%s\" needs to be generated" % mesh_name)}
    BED_MESH_STORE SAVE=none PARK=false
  {% else %}
    {action_respond_info("BED_MESH: ERROR \"%s\" not defined" % mesh_name)}
  {% endif %}

## add this to your PRINT_END to save a mesh if needed 10 seconds after print ended
## UPDATE_DELAYED_GCODE ID=_BED_MESH_SAVE DURATION=10
[delayed_gcode _BED_MESH_SAVE]
gcode:
  {% if printer["gcode_macro MESH_STORE"].save_at_end %}
    {action_respond_info("BED_MESH: Save Config!")}
    SAVE_CONFIG
  {% endif %}